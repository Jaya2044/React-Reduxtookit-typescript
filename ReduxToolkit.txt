Redux is an open source Javascript library for managing application state.

Redux is a state management tool for Javascript applications.

Redux stores the state of the application.

By using RTK we can simplifies the redux code.


Redux drawbacks:
=================

1. We may need to write more code to implement redux in application, which 
can increases overall complexity.

2. Redux requires a lot of bipolerate code to set up the store, actions & 
reducers this can be time consuming.

3. Redux may be overkill for simple applications that dont have complex 
data flows.

4. thunk setup is required for redux but thunk setup is not required for RTK.

5. Configuring a Redux store is too complicated

6. Have to add a lot of packages


RTK is the officially recommended approach to write any redux code.


Important features provided with RTK:
=======================================

1. Automatic support for Redux-thunk, Redux DevTools Extension, and default 
middleware is provided by configureStore() function

2. create action and create Reducer functions are replaced with a single function 
called createSlice() function.

3. createAsyncThunk() that takes Redux strings as arguments and returns a Promise.

4. CRUD operations are performed using createEntityAdapter() utility.


We have main 3 concepts:

    1. store
    2. actions
    3. reducers


Three principles:
===================

1. Maintain our application state in single object which would be 
managed by the redux store.

2. The only way to change the state is to dispatch an action. we 
can not directly update the state object.

3. By using reducers only we can specify how the state tree is 
updated based on actions.


Actions:
==========

1. Actions are plain Javascript objects.

2. We can not directly update the state. we have only one way is 
to dispatch an action.

3. It carries a payload of information from application to redux store.

4. action having a type property which will defined as string constants.
what kind of action needs to be trigger like increment, decrement, login,
logout etc...

Syntax:
---------

const PRODUCT_ORDERED = "PRODUCT_ORDERED";

function ProductOrder() {
  return {
    type: PRODUCT_ORDERED,
    quantity: 1
  }
}

const intialState = {
  numOfProducts: 10
}


Reducers:
==========

reducers are the functions and it accepts two arguments:

    1. state
    2. action

based on the state & action it will return the new state.

Example:
---------

const PRODUCT_ORDERED = "PRODUCT_ORDERED";

function ProductOrder() {
  return {
    type: PRODUCT_ORDERED,
    quantity: 1
  }
}

const intialState = {
  numOfProducts: 10
}

const ProductReducer = (state = intialState, action) => {
  switch(action.type){
    case PRODUCT_ORDERED: 
      return {
        ...state,
        numOfProducts: state.numOfProducts - 1
      }
      
    default:
      return state;
  }
}



Store:
=======

One store for an entire application.

Responsibilities:

    1. Holds application state
    2. Allows access to state via getState()
    3. Allows state to be updated via dispatch
    4. Registers listeners via subscribe.


Example:
---------

const createStore = require("redux");

const PRODUCT_ORDERED = "PRODUCT_ORDERED";
const RESTOCK_ORDER = "RESTOCK_ORDER";


function ProductOrder() {
  return {
    type: PRODUCT_ORDERED,
    quantity: 1,
  };
}

function ReStockOrder(qty=1) {
  return {
    type: RESTOCK_ORDER,
    quantity: qty
  };
}

const intialState = {
  numOfProducts: 10,
};

const ProductReducer = (state = intialState, action) => {
  switch (action.type) {
    case PRODUCT_ORDERED:
      return {
        ...state,
        numOfProducts: state.numOfProducts - 1,
      };

    case RESTOCK_ORDER:
      return {
        ...state,
        numOfProducts: state.numOfProducts + action.quantity
      };

    default:
      return state;
  }
};

const store = createStore(ProductReducer);
console.log("Initial State", store.getState());

const unsubscribe = store.subscribe(() =>
  console.log("updated store", store.getState())
);

store.dispatch(ProductOrder());
store.dispatch(ProductOrder());
store.dispatch(ProductOrder());
store.dispatch(ReStockOrder(3));

unsubscribe();



Bind action creators:
=======================

action creators are functions that return the actions.

bindActionCreators really not necessary.

const actions = bindActionCreators({ProductOrder, ReStockOrder}, store.dispatch);
actions.ProductOrder();
actions.ProductOrder();
actions.ProductOrder();
actions.ReStockOrder(3);

unsubscribe();


Multiple Reducers:
====================

we can create multiple reducers and we have combineReducers to combine 
the reducers.

redux provided the combineReducers utility.

const rootReducer = combineReducers({
  counter: CounterReducer,
  user: UserReducer
})

const store = createStore(rootReducer)
console.log(store.getState());


Immer:
=======

Immer should be used when we have complex state in redux.

when we are working nexted objects not easy to handle state in reducer 
file.

Immer libray will provide produce function. 

npm install immer 

const initiaState = {
  name: 'Jaya',
  address: {
    street:'Vasanth Nagar Colony',
    city:'Hyderabad',
    state: 'Telangana'
  }
};


const STATE_UPDATED = "STATE_UPDATED";

const StateUpdated = (street) => {
  return {
    type: STATE_UPDATED,
    payload: street
  }
} 


const StateReducer = (state=initiaState, action) {
  switch(action.type) {
    case STATE_UPDATED:
      return {
        ...state,
        address: {
          ...state.address,
          street: action.payload 
        }
      }
    default: 
      return state;
  }
}


const store = redux.createStore(StateReducer);

console.log('Initial State', store.getState());

const unsubscribe = store.subscribe(() => {
  console.log('Updated state', store.getState())
})

store.dispatch(StateUpdated('Andhra'))
unsubscribe();


Immer is a library that simplifies the process of writing 
immutable update logic. we can write the code like below:

const StateReducer = (state=initiaState, action) {
  switch(action.type) {
    case STATE_UPDATED:
      return produce(state, (draft) => {
        draft.address.street = action.payload;
      })
    default: 
      return state;
  }
}



Middleware:
============

Redux supports for middleware.

Using middleware for logging, reporting and making async tasks etc..

we have redux-thunk and redux-saga


redux-logger:
---------------

npm i --save redux-logger

redux-logger logs all the information related to redux in the 
application.

redux will provide a function called applyMiddleware() which is 
used to apply the middleware.

const reduxLogger = require('redux-logger');
const logger = reduxLogger.createLogger();

const store = redux.createStore(StateReducer, applyMiddleware(logger));



Async Actions:
================

Sync Actions:
--------------

  If we dispatch any action that state will be immediately updated.

Async Actions:
---------------

  API calls to fetch the data from end point and that data we will 
  use in applications.


State Preparation:
-------------------

state = {
  loading: true,
  users:[],
  error:''
}

loading - display a loading spinner in component
users - list of user data 
error - display error to the user.


Actions Types:
---------------

FETCH_USERS_REQUESTED -> Fetch list of users 

FETCH_USERS_SUCCESS  -> fetched successfully

FETCH_USERS_FAIL -> error when fetching the data


Reducer:
--------

case FETCH_USERS_REQUESTED:
  loading: true
  data:[],
  error:''

case FETCH_USERS_SUCCESS:
  loading: false,
  users: data (from api)
  error: ''

case FETCH_USERS_FAIL:
  loading: false,
  users: []
  error: error (from api)


Example:
==========

const redux = require('redux');
const createStore = redux.createStore;

const initialState = {
  loading: false,
  users: [],
  error: '',
};

const FETCH_USERS_REQUESTED = 'FETCH_USERS_REQUESTED';
const FETCH_USERS_SUCCESS = 'FETCH_USERS_SUCCESS';
const FETCH_USERS_FAIL = 'FETCH_USERS_FAIL';

const fetchUsersRequest = () => {
  return {
    type: FETCH_USERS_REQUESTED,
  };
};

const fetchUsersSuccess = (users) => {
  return {
    type: FETCH_USERS_SUCCESS,
    payload: users,
  };
};

const fetchUsersFail = (error) => {
  return {
    type: FETCH_USERS_FAIL,
    payload: error,
  };
};

const userReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_USERS_REQUESTED:
      return {
        ...state,
        loading: true,
      };
    case FETCH_USERS_SUCCESS:
      return {
        ...state,
        loading: false,
        users: action.payload,
        error: '',
      };
    case FETCH_USERS_FAIL:
      return {
        ...state,
        loading: false,
        users: [],
        error: action.payload,
      };
  }
};

const store = createStore(userReducer);


Redux thunk Middleware:
=========================

we have to install:

  npm install redux-thunk or redux-saga
  
  npm install axios

By using redux-thunk we can define a async action creators.

redux-thunk library is a middleware we will be applying to redux store.

Example:
---------

const fetchUsers = () => {
  return function (dispatch) {
    dispatch(fetchUsersRequest());
    axios
      .get('https://jsonplaceholder.typicode.com/users')
      .then((response) => {
        const users = response.data.map((user) => user.username);
        dispatch(fetchUsersSuccess(users));
      })
      .catch((error) => {
        dispatch(fetchUsersFail(error));
      });
  };
};

const store = createStore(userReducer, applyMiddleware(thunkMiddleware));

store.subscribe(() => {
  console.log(store.getState());
});

store.dispatch(fetchUsers());

************************************************************************


Redux Toolkit:
==============

Redux concerns:
----------------

1. Redux requires too much bipolerate code:
    Action
    Action object
    Action creator
    Switch statement in a reducer

2. A Lot of other packages need to be installed:

    redux-thunk
    immer
    redux-DevTools

3. RTK will provide support for redux-thunk and dev DevTools without 
   installing packages.

  
npm install @reduxjs/toolkit

we will create features folder and this folder contains all the features
of our application.

The entire application state split into slices and manage individually.

createSlice will Automatically generate action creators with same names
as the reducer functions we have written.

folder structure:
  features  
    cake
      cakeSlice.js


cakeSlice.js:
==============

const createSlice = require("@reduxjs/toolkit").createSlice;

const initialState = {
  numOfCakes: 10,
};

const CakeSlice = createSlice({
  name: "cake",
  initialState,
  reducers: {
    cakeOrdered: (state) => {
      state.numOfCakes--;
    },
    cakeRestock: (state, action) => {
      state.numOfCakes += action.payload;
    },
  },
});

module.exports = CakeSlice.reducer;
module.exports.CakeActions = CakeSlice.actions;


icecreamSlice.js:
------------------

const createSlice = require("@reduxjs/toolkit").createSlice;

const initialState = {
  numOfIcecreams: 20,
};

const IcecreamSlice = createSlice({
  name: "icecream",
  initialState,
  reducers: {
    ordered: (state) => {
      state.numOfIcecreams--;
    },
    restocked: (state, action) => {
      state.numOfIcecreams += action.payload;
    },
  },
});

module.exports = IcecreamSlice.reducer;
module.exports.IcecreamActions = IcecreamSlice.actions;



Configuring Store:
====================

we use createStore in redux but in RTK we will use configureStore.

we need to import from @reduxjs/toolkit

store.js:
----------

const configureStore = require("@reduxjs/toolkit").configureStore;
const CakeReducer = require("../features/Cake/cakeSlice");
const IcecreamReducer = require("../features/Icecream/IcecreamSlice");

const store = configureStore({
  reducer: {
    cake: CakeReducer,
    icecream: IcecreamReducer,
  },
});

module.exports = store;



index.js:
----------

const store = require("./store");
const cakeActions = require("../features/Cake/cakeSlice").CakeActions;
const icecreamActions =
  require("../features/Icecream/IcecreamSlice").IcecreamActions;

console.log("Initial State", store.getState());
const unsubscribe = store.subscribe(() => {
  console.log("Update state", store.getState());
});

store.dispatch(cakeActions.cakeOrdered());
store.dispatch(cakeActions.cakeOrdered());
store.dispatch(cakeActions.cakeOrdered());
store.dispatch(cakeActions.cakeRestock(3));

store.dispatch(icecreamActions.ordered());
store.dispatch(icecreamActions.ordered());
store.dispatch(icecreamActions.restocked(2));

unsubscribe();


output:
--------

Initial State { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }
Update state { cake: { numOfCakes: 9 }, icecream: { numOfIcecreams: 20 } }
Update state { cake: { numOfCakes: 8 }, icecream: { numOfIcecreams: 20 } }
Update state { cake: { numOfCakes: 7 }, icecream: { numOfIcecreams: 20 } }
Update state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }
Update state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 19 } }
Update state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 18 } }
Update state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }


we can dispatch the actions like below:

const actions = actionCreators(
  {
    cakeOrdered,
    cakeRestock,
    ordered,
    restocked,
  },
  store.dispatch
);

actions.cakeOrdered();
actions.cakeOrdered();
actions.cakeOrdered();
actions.cakeRestock(3);

actions.ordered();
actions.ordered();
actions.restocked(2);



Logger Middleware:
===================

npm install redux-logger

we will specify middleware property after the reducer in store file to 
apply the logger.

store.js:
---------

const configureStore = require("@reduxjs/toolkit").configureStore;
const CakeReducer = require("../features/Cake/cakeSlice");
const IcecreamReducer = require("../features/Icecream/IcecreamSlice");
const logger = require("redux-logger");

const reduxLogger = logger.createLogger();

const store = configureStore({
  reducer: {
    cake: CakeReducer,
    icecream: IcecreamReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(reduxLogger),
});

module.exports = store;


output:
--------

Initial State { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }

Update state { cake: { numOfCakes: 9 }, icecream: { numOfIcecreams: 20 } }
 action cake/cakeOrdered @ 19:03:16.126
   prev state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }
   action     { type: 'cake/cakeOrdered', payload: undefined }
   next state { cake: { numOfCakes: 9 }, icecream: { numOfIcecreams: 20 } }

Update state { cake: { numOfCakes: 8 }, icecream: { numOfIcecreams: 20 } }
 action cake/cakeOrdered @ 19:03:16.129
   prev state { cake: { numOfCakes: 9 }, icecream: { numOfIcecreams: 20 } }
   action     { type: 'cake/cakeOrdered', payload: undefined }
   next state { cake: { numOfCakes: 8 }, icecream: { numOfIcecreams: 20 } }
   
Update state { cake: { numOfCakes: 7 }, icecream: { numOfIcecreams: 20 } }
 action cake/cakeOrdered @ 19:03:16.132
   prev state { cake: { numOfCakes: 8 }, icecream: { numOfIcecreams: 20 } }
   action     { type: 'cake/cakeOrdered', payload: undefined }
   next state { cake: { numOfCakes: 7 }, icecream: { numOfIcecreams: 20 } }
   
Update state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }
 action cake/cakeRestock @ 19:03:16.134
   prev state { cake: { numOfCakes: 7 }, icecream: { numOfIcecreams: 20 } }
   action     { type: 'cake/cakeRestock', payload: 3 }
   next state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }

Update state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 19 } }
 action icecream/ordered @ 19:03:16.136
   prev state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }
   action     { type: 'icecream/ordered', payload: undefined }
   next state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 19 } } 

Update state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 18 } }
 action icecream/ordered @ 19:03:16.138
   prev state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 19 } }
   action     { type: 'icecream/ordered', payload: undefined }
   next state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 18 } }

Update state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }
 action icecream/restocked @ 19:03:16.140
   prev state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 18 } }
   action     { type: 'icecream/restocked', payload: 2 }
   next state { cake: { numOfCakes: 10 }, icecream: { numOfIcecreams: 20 } }


getDefaultMiddleware is useful if we want to add some custom middleware.


createAction & createReducer:
================================

instead of switch cases in redux we can simplify the code like below
in redux toolkit:

import { createAction, createReducer } from '@reduxjs/toolkit'

const increment = createAction('counter/increment')
const decrement = createAction('counter/decrement')
const incrementByAmount = createAction('counter/incrementByAmount')

const initialState = { value: 0 }

const counterReducer = createReducer(initialState, (builder) => {
  builder
    .addCase(increment, (state, action) => {
      state.value++
    })
    .addCase(decrement, (state, action) => {
      state.value--
    })
    .addCase(incrementByAmount, (state, action) => {
      state.value += action.payload
    })
})



Async Thunk:
==============

userSlice.js:
--------------

const createSlice = require("@reduxjs/toolkit").createSlice;
const createAsyncThunk = require("@reduxjs/toolkit").createAsyncThunk;
const axios = require("axios");

const initialState = {
  loading: false,
  users: [],
  error: "",
};

const fetchUsers = createAsyncThunk("user/fetchUsers", () => {
  return axios
    .get("https://jsonplaceholder.typicode.com/users")
    .then((response) => response.data.map((user) => user.id));
});

const userSlice = createSlice({
  name: "user",
  initialState,
  extraReducers: (builder) => {
    builder.addCase(fetchUsers.pending, (state) => {
      state.loading = true;
    });
    builder.addCase(fetchUsers.fulfilled, (state, action) => {
      state.loading = false;
      state.users = action.payload;
      state.error = "";
    });
    builder.addCase(fetchUsers.rejected, (state, action) => {
      state.loading = false;
      state.users = [];
      state.error = action.payload;
    });
  },
});

module.exports = userSlice.reducer;
module.exports.fetchUsers = fetchUsers;


index.js:
----------

const fetchUsers = require("../features/user/userSlice").fetchUsers;

console.log("Initial State", store.getState());
const unsubscribe = store.subscribe(() => {
  console.log("Update state", store.getState());
});

store.dispatch(fetchUsers());


store.js:
----------

const store = configureStore({
  reducer: {
    cake: CakeReducer,
    icecream: IcecreamReducer,
    user: userReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(reduxLogger),
});


output:
---------

Initial State {
  cake: { numOfCakes: 10 },
  icecream: { numOfIcecreams: 20 },
  user: { loading: false, users: [], error: '' }
}
Update state {
  cake: { numOfCakes: 10 },
  icecream: { numOfIcecreams: 20 },
  user: { loading: true, users: [], error: '' }
}
 action user/fetchUsers/pending @ 21:00:01.196
   prev state {
    cake: { numOfCakes: 10 },
    icecream: { numOfIcecreams: 20 },
    user: { loading: false, users: [], error: '' }
  }
   action     {
    type: 'user/fetchUsers/pending',
    payload: undefined,
    meta: {
      arg: undefined,
      requestId: 'HsjAehjZ548KE3Ft6ewTM',
      requestStatus: 'pending'
    }
  }
   next state {
    cake: { numOfCakes: 10 },
    icecream: { numOfIcecreams: 20 },
    user: { loading: true, users: [], error: '' }
  }
Update state {
  cake: { numOfCakes: 10 },
  icecream: { numOfIcecreams: 20 },
  user: {
    loading: false,
    users: [
      1, 2, 3, 4,  5,
      6, 7, 8, 9, 10
    ],
    error: ''
  }
}
 action user/fetchUsers/fulfilled @ 21:00:01.662
   prev state {
    cake: { numOfCakes: 10 },
    icecream: { numOfIcecreams: 20 },
    user: { loading: true, users: [], error: '' }
  }
   action     {
    type: 'user/fetchUsers/fulfilled',
    payload: [
      1, 2, 3, 4,  5,
      6, 7, 8, 9, 10
    ],
    meta: {
      arg: undefined,
      requestId: 'HsjAehjZ548KE3Ft6ewTM',
      requestStatus: 'fulfilled'
    }
  }
   next state {
    cake: { numOfCakes: 10 },
    icecream: { numOfIcecreams: 20 },
    user: {
      loading: false,
      users: [
        1, 2, 3, 4,  5,
        6, 7, 8, 9, 10
      ],
      error: ''
    }
  }


React Project Setup:
=======================

npx create-react-app react-rtk-demo

npm install axios 

npm install @reduxjs/toolkit

npm install react-redux

With plain redux we have to manually install and apply the extension to 
the redux store.

redux toolkit will provide support for redux devtools without installing 
any packages.

src
  app 
    store.js
  features 
    Cake
      CakeSlice.js
      CakeView.jsx
    Icecream 
      IcecreamSlice.js
      IcecreamView.jsx
    User
      UserSlice.js
      UserView.jsx
    

CakeSlice.js:
---------------

import { createSlice } from "@reduxjs/toolkit";

const initialState = {
  numOfCakes: 10,
};

const CakeSlice = createSlice({
  name: "cake",
  initialState,
  reducers: {
    cakeOrdered: (state) => {
      state.numOfCakes--;
    },
    cakeRestock: (state, action) => {
      state.numOfCakes += action.payload;
    },
  },
});

export default CakeSlice.reducer;
export const { cakeOrdered, cakeRestock } = CakeSlice.actions;


CakeView.jsx:
--------------

import React from "react";
import { useSelector, useDispatch } from "react-redux";
import { cakeOrdered, cakeRestock } from "./cakeSlice";

const CakeView = () => {
  const cakes = useSelector((state) => state.cake.numOfCakes);
  const dispatch = useDispatch();
  return (
    <div>
      <h2>Number of cakes - {cakes}</h2>
      <button onClick={() => dispatch(cakeOrdered())}>Order Cake</button>
      &nbsp;&nbsp;
      <button onClick={() => dispatch(cakeRestock(5))}>Restock Cake</button>
    </div>
  );
};

export default CakeView;


IcecreamSlice.js:
-------------------

import { createSlice } from "@reduxjs/toolkit";

const initialState = {
  numOfIcecreams: 20,
};

const IcecreamSlice = createSlice({
  name: "icecream",
  initialState,
  reducers: {
    ordered: (state) => {
      state.numOfIcecreams--;
    },
    restocked: (state, action) => {
      state.numOfIcecreams += action.payload;
    },
  },
});

export default IcecreamSlice.reducer;
export const { ordered, restocked } = IcecreamSlice.actions;



IcecreamView.jsx:
-------------------

import React, { useState } from "react";
import { useSelector, useDispatch } from "react-redux";
import { ordered, restocked } from "./IcecreamSlice";

const IcecreamView = () => {
  const [inputVal, setInputVal] = useState("");
  const icecreams = useSelector((state) => state.icecream.numOfIcecreams);
  const dispatch = useDispatch();

  const handleChange = (e) => {
    setInputVal(parseInt(Number(e.target.value)));
  };

  return (
    <div>
      <h2>Number of Icecreams - {icecreams}</h2>

      <button onClick={() => dispatch(ordered())}>
        Order Icecream
      </button>

      &nbsp;&nbsp;
      <input
        type="number"
        value={inputVal == "" ? "" : inputVal}
        onChange={handleChange}
      />
      &nbsp;&nbsp;

      <button onClick={() => dispatch(restocked(inputVal))}>
        Restock Icecream
      </button>
    </div>
  );
};

export default IcecreamView;


UserSlice.js:
--------------

import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";

const initialState = {
  loading: false,
  users: [],
  error: "",
};

export const fetchUsers = createAsyncThunk("user/fetchUsers", () => {
  return axios
    .get("https://jsonplaceholder.typicode.com/users")
    .then((response) => response.data);
});

const userSlice = createSlice({
  name: "user",
  initialState,
  extraReducers: (builder) => {
    builder.addCase(fetchUsers.pending, (state) => {
      state.loading = true;
    });
    builder.addCase(fetchUsers.fulfilled, (state, action) => {
      state.loading = false;
      state.users = action.payload;
      state.error = "";
    });
    builder.addCase(fetchUsers.rejected, (state, action) => {
      state.loading = false;
      state.users = [];
      state.error = action.error.message;
    });
  },
});

export default userSlice.reducer;



UserView.jsx:
--------------

import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { fetchUsers } from "./userSlice";

const UserView = () => {
  const user = useSelector((state) => state.user);
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(fetchUsers());
  }, []);

  return (
    <div>
      <h2>List of users</h2>
      {user.loading && <div>Loading...</div>}
      {!user.loading && user.error ? <div>Error: {user.error}</div> : null}
      {!user.loading && user.users.length ? (
        <ul>
          {user.users.map((user) => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      ) : null}
    </div>
  );
};

export default UserView;


App.jsx:
----------

import './App.css';
import CakeView from "./features/Cake/CakeView";
import IcecreamView from "./features/Icecream/IcecreamView";
import UserView from "./features/user/UserView"

function App() {
  return (
    <div className="App">
        <CakeView />
        <hr />
        <IcecreamView />
        <hr />
        <UserView />
    </div>
  );
}

export default App;


store.js:
----------

import { configureStore } from "@reduxjs/toolkit";
import CakeReducer from "../features/Cake/cakeSlice";
import IcecreamReducer from "../features/Icecream/IcecreamSlice";
import userReducer from "../features/user/userSlice";
import { createLogger } from "redux-logger";

const store = configureStore({
  reducer: {
    cake: CakeReducer,
    icecream: IcecreamReducer,
    user: userReducer,
  },
});

export default store;


index.jsx:
-----------

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import { Provider } from 'react-redux';
import store from "./app/store"
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
        <App />
    </Provider>
  </React.StrictMode>
);



Typescript Support:
====================

npx create-react-app react-rtk-ts --template typescript

npm install axios react-redux @reduxjs/toolkit

CakeSlice.ts:
---------------

import { PayloadAction, createSlice } from "@reduxjs/toolkit";

type StateType = {
    numOfCakes: number
}

const initialState: StateType = {
    numOfCakes: 10
}

const CakeSlice = createSlice({
    name:'cakes',
    initialState,
    reducers: {
        cakeOrder: (state) => {
            state.numOfCakes--
        },
        cakeRestock: (state, action: PayloadAction<number>) => {
            state.numOfCakes += action.payload
        }
    }
})

export default CakeSlice.reducer;
export const { cakeOrder, cakeRestock } = CakeSlice.actions



IcecreamSlice.ts
------------------
import { PayloadAction, createSlice } from "@reduxjs/toolkit";

type StateType = {
    numOfIcecreams: number
}

const initialState: StateType = {
    numOfIcecreams: 20
}

const IcecreamSlice = createSlice({
    name:'Icecreams',
    initialState,
    reducers: {
        IcecreamOrder: (state) => {
            state.numOfIcecreams--
        },
        IcecreamRestock: (state, action: PayloadAction<number>) => {
            state.numOfIcecreams += action.payload
        }
    }
})

export default IcecreamSlice.reducer;
export const { IcecreamOrder, IcecreamRestock } = IcecreamSlice.actions


UsersSlice.ts:
---------------
import { createSlice, createAsyncThunk, PayloadAction } from "@reduxjs/toolkit";
import axios from "axios";

type User = {
  id: number;
  name: string;
};

type StateType = {
  loading: boolean;
  users: User[];
  error: string;
};

const initialState: StateType = {
  loading: false,
  users: [],
  error: "",
};

export const fetchUsers = createAsyncThunk("users/fetchUsers", () => {
  return axios
    .get("https://jsonplaceholder.typicode.com/users")
    .then((response) => response.data);
});

const UserSlice = createSlice({
  name: "users",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder.addCase(fetchUsers.pending, (state) => {
      state.loading = true;
    });
    builder.addCase(fetchUsers.fulfilled, (state, action:PayloadAction<User[]>) => {
        state.loading = false;
        state.users = action.payload;
        state.error = ''
    });
    builder.addCase(fetchUsers.rejected, (state, action)=> {
        state.loading = false;
        state.users = [];
        state.error = action.error.message || 'Something went wrong'
    })
  },
});

export default UserSlice.reducer;


Store.ts:
----------

import { configureStore } from "@reduxjs/toolkit";
import CakeReducer from "../features/Cake/CakeSlice"
import IcecreamReducer from "../features/Icecream/IcecreamSlice";
import UsersReducer from "../features/Users/UsersSlice";

const store = configureStore({
    reducer: {
        cakes: CakeReducer,
        icecreams: IcecreamReducer,
        users: UsersReducer
    }
});

export default store;
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;


hooks.ts:
----------

import type { AppDispatch, RootState } from "./Store";
import { TypedUseSelectorHook, useSelector, useDispatch } from "react-redux";

export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;
export const useAppDispatch = () => useDispatch<AppDispatch>()


index.tsx:
------------

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import { Provider } from 'react-redux';
import store from './app/Store';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
     <Provider store={store}>
        <App />
     </Provider>
  </React.StrictMode>
);



App.tsx:
---------

import React from 'react';
import logo from './logo.svg';
import './App.css';
import CakeView from './features/Cake/CakeView';
import IcecreamView from './features/Icecream/IcecreamView';
import UsersView from './features/Users/UsersView';

function App() {
  return (
    <div className="App">
      <CakeView />
      <hr />
      <IcecreamView />
      <hr />
      <UsersView />
    </div>
  );
}

export default App;


CakeView.tsx:
--------------

import React from 'react'
import { useSelector } from 'react-redux'
import { useAppDispatch, useAppSelector } from '../../app/hooks';
import { cakeOrder, cakeRestock } from './CakeSlice';

const CakeView = () => {
  const cakes = useAppSelector((state) => state.cakes.numOfCakes);
  const dispatch = useAppDispatch();
  return (
    <div>
      <h2>Number of Cakes - {cakes}</h2>
      <button onClick={() => dispatch(cakeOrder())}>Cake Order</button>&nbsp;&nbsp;
      <button onClick={() => dispatch(cakeRestock(5))}>Cake Restock</button>
    </div>
  )
}

export default CakeView


IcecreamView.tsx:
-------------------

import React, { ChangeEvent, useState } from "react";
import { useAppDispatch, useAppSelector } from "../../app/hooks";
import { IcecreamOrder, IcecreamRestock } from "./IcecreamSlice";

const IcecreamView = () => {
  const Icecreams = useAppSelector((state) => state.icecreams.numOfIcecreams);
  const dispatch = useAppDispatch();
  const [InputVal, setInputVal] = useState(0);

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setInputVal(parseInt(e.target.value));
  };
  return (
    <div>
      <h2>Number of Icecreams - {Icecreams}</h2>
      <button onClick={() => dispatch(IcecreamOrder())}>Icecream Order</button>
      &nbsp;&nbsp;
      <input
        type="number"
        value={InputVal === 0 ? "" : InputVal}
        onChange={handleChange}
      />
      &nbsp;&nbsp;
      <button onClick={() => dispatch(IcecreamRestock(InputVal))}>
        Icecream Restock
      </button>
    </div>
  );
};

export default IcecreamView;



UsersView.tsx:
----------------

import React, { useEffect } from 'react'
import { useAppDispatch, useAppSelector } from '../../app/hooks'
import { fetchUsers } from './UsersSlice';

const UsersView = () => {
  const user = useAppSelector((state) => state.users);
  const dispatch = useAppDispatch();

  useEffect(() => {
    dispatch(fetchUsers())
  }, []);

  return (
    <div>
     <h2>List of users</h2>
     {user.loading && <div>Loading....</div>}
     {!user.loading && user.error ? <div>Error: {user.error}</div>: null}
     {
      !user.loading && user.users.length ? (
        <ul>
          {
            user.users.map((user) => (
              <li key={user.id}>{user.name}</li>
            ))
          }
        </ul>
      ): null
     }
    </div>
  )
}

export default UsersView





